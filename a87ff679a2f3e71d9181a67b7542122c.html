<!doctype html>
<html>
<head><meta charset="utf-8"><title>Proxima â€” Transmission</title>

<style>
@keyframes flicker {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.95;
    }
}

@keyframes textGlitch {
    0%, 95%, 100% {
    
    }
    5% {
    
    }
    10% {
    
    }
}

@keyframes float {
    0%, 100% {
        transform: translate(-50%, -50%) translateY(0px);
    }
    50% {
        transform: translate(-50%, -50%) translateY(-8px);
    }
}

body {
    background-color: black;
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: 'Courier New', monospace;
    position: relative;
    overflow: hidden;
}

/* Canvas styling */
#sphereCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    background: #1b1b1b;
}

/* Text content centered on sphere */
.text-content {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 500px;
    max-width: 80vw;
    text-align: center;
    z-index: 10;
    animation: float 4s ease-in-out infinite;
    pointer-events: none;
}

.box pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow-wrap: break-word;
    margin: 0;
    font-family: inherit;
    line-height: 1.4;


    font-size: 14px;
    color: white;
    font-weight: bold;
}

.box p {
    margin: 0;
    line-height: 1.3;


    font-size: 12px;
    color: white;
    font-weight: bold;
}

.box code {
    background-color: rgba(255, 255, 255, 0.2);
    padding: 1px 3px;
    border: 1px solid white;
    border-radius: 2px;

    font-size: 11px;
    font-weight: bold;
}

/* Transmission header effect */
.transmission-header {
    position: absolute;
    top: -50px;
    left: 0;
    right: 0;
    text-align: center;
    font-size: 11px;
    color: white;
    opacity: 0.9;
    z-index: 10;
    font-weight: bold;
}

.transmission-header::before {
    content: 'INCOMING TRANSMISSION';
}

.transmission-header::after {
    content: 'SIGNAL STRENGTH: 79%';
    display: block;
    font-size: 9px;
    margin-top: 3px;
    animation: flicker 3s infinite, textGlitch 4s infinite;
    text-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
}

/* Glitch overlay */
.glitch-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(transparent, rgba(255, 255, 255, 0.03), transparent);
    pointer-events: none;

    z-index: 2;
}
</style>

</head><body>
<canvas id="sphereCanvas"></canvas>
<div class="text-content">
    <div class="transmission-header"></div>
    <div class="box">
        <pre>Binary decodes to 'Voyager 2'. Open Voyager 2 page and extract the year it crossed into interstellar space (four digits).

</pre>
        <hr style="border:none;border-top:1px solid white;margin:12px 0;opacity:0.5;">
        <p style="font-size:12px">When you extract the required fact from the external source, normalize it to <strong>lowercase without spaces</strong>, then compute its <strong>MD5 (hex)</strong>. Open that filename (e.g. <code>abcdef012345....html</code>) in this same folder to continue.</p>
    </div>
</div>
<div class="glitch-overlay"></div>

<script>
    const canvas = document.getElementById('sphereCanvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas size
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Configuration
    const CONFIG = {
        SPHERE_RADIUS: 400,
        DOT_COUNT: 150,
        ROTATION_SPEED: 0.002,
        PERSPECTIVE: 800,
        DOT_SIZE: 4,
        AMBIENT_LIGHT: 0.3,
    };

    // Initialize points
    const points = [];
    for (let i = 0; i < CONFIG.DOT_COUNT; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);
        
        points.push({
            x: CONFIG.SPHERE_RADIUS * Math.sin(phi) * Math.cos(theta),
            y: CONFIG.SPHERE_RADIUS * Math.sin(phi) * Math.sin(theta),
            z: CONFIG.SPHERE_RADIUS * Math.cos(phi),
            prevX: null,
            prevY: null
        });
    }

    // Animation variables
    let angleX = 0;
    let angleY = 0;
    const center = { x: canvas.width / 2, y: canvas.height / 2 };

    function rotatePoint(point, ax, ay) {
        let y = point.y * Math.cos(ax) - point.z * Math.sin(ax);
        let z = point.z * Math.cos(ax) + point.y * Math.sin(ax);
        let x = point.x * Math.cos(ay) - z * Math.sin(ay);
        z = z * Math.cos(ay) + point.x * Math.sin(ay);
        return { x, y, z };
    }

    function draw() {
        // Dim the canvas slightly instead of fully clearing (keeps trails)
        ctx.fillStyle = 'rgba(5, 5, 5, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Update angles
        angleX += CONFIG.ROTATION_SPEED;
        angleY += CONFIG.ROTATION_SPEED * 0.8;

        // Sort points by Z depth for proper layering
        const sortedPoints = points.map(point => {
            const rotated = rotatePoint(point, angleX, angleY);
            return { ...point, rotated, depth: rotated.z };
        }).sort((a, b) => b.depth - a.depth);

        sortedPoints.forEach(({ rotated, prevX, prevY }) => {
            const depth = CONFIG.PERSPECTIVE / (CONFIG.PERSPECTIVE - rotated.z);
            const x = center.x + rotated.x * depth;
            const y = center.y + rotated.y * depth;
            
            const light = Math.max(CONFIG.AMBIENT_LIGHT, 
                (rotated.z / CONFIG.SPHERE_RADIUS) * 2
            );

            if (prevX !== null && prevY !== null) {
                ctx.strokeStyle = `rgba(255, 255, 255, ${light})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(prevX, prevY);
                ctx.lineTo(x, y);
                ctx.stroke();
            }

            if (rotated.z < CONFIG.PERSPECTIVE) {
                ctx.beginPath();
                ctx.fillStyle = `rgba(255, 255, 255, ${light})`;
                ctx.arc(x, y, CONFIG.DOT_SIZE * depth * 0.1, 0, Math.PI * 2);
                ctx.fill();
            }

            // Update previous position
            const pointIndex = points.findIndex(p => p === points.find(p2 => 
                p2.x === rotated.x && p2.y === rotated.y && p2.z === rotated.z
            ));
            if (pointIndex !== -1) {
                points[pointIndex].prevX = x;
                points[pointIndex].prevY = y;
            }
        });

        requestAnimationFrame(draw);
    }

    // Start animation
    draw();

    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        center.x = canvas.width / 2;
        center.y = canvas.height / 2;
    });
</script>
</body></html>







